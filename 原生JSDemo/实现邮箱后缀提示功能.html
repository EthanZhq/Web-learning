<!DOCTYPE html>
<html lang="en">
<head>
	<!-- 实现一个邮箱输入的提示功能 -->
	<meta charset="UTF-8">
	<title>write a letter for your love</title>
    <style>
    #input-email {
        width: 300px;
        height: 30px;
    }
    .email-sug{
        width: 300px;
        list-style: none;
        padding: 0px;
        margin: 0px;
        border: 2px solid rgba(134, 132, 132,0.3);
        border-top: none;
        display: none; /* 初始不显示，避免边框出现 */
    }
    .email-sug li {
        width: 300px;
        height: 30px;
        background-color: #ffffff;
        color: darkgrey;
        line-height: 30px;
    }
    .email-sug li:hover {
        background-color: pink;
	}

	.email-sug li.active {
        background-color:pink;
    }
	</style>
</head>
<body>
	<div class="wrapper">
		<input type="text" id="email-input" autofocus="autofocus">
		<ul id="email-sug-wrapper" class="email-sug"></ul>
	</div>

<!--
需求：
1、根据下面需求实现如示意图所示的邮箱输入提示功能，注意，根据要求只需实现下面功能
2、当用户没有任何输入时，提示框消失
3、当用户输入字符后，显示提示框，并且把用户输入的内容自动拼上邮箱后缀进行显示
4.使用CSS实现：鼠标滑过提示框的某一个提示时，这个提示内容背景色变化，表示鼠标经过了这个DOM节点
5.鼠标如果点击某个提示，则提示内容进入输入框，同时提示框消失
6.在上个步骤结束后，在输入框中任意再输入字符或删除字符，则重新开始出现提示框
注意用户输入中前后空格需要去除
-->
<!--
键盘事件需求：
1.我们给提示框加上3个按键的功能，分别是回车和上下键，使得可以通过键盘操作进行提示框的选择
2.当有提示框的时候，默认第一个提示为被选择状态，用一个和鼠标滑过不一样的背景色来标识
3.当有输入框的时候，按上键，可以向上移动选择状态，如果按键之前的被选择提示是第一个，则被选状态移到最下面一个
4.当有输入框的时候，按下键，可以向下移动选择状态，如果按键之前的被选择提示是最后一个，则被选状态移到第一个
5.当有输入框时，按回车键，则将当前被选中状态的提示内容，放到输入框中，并隐藏提示框
6.当没有输入框的时候，这3个键盘按键无响应
7.当用户输入发生改变的时候，选择状态都重新切回到第一个提示
-->
	<script>
		var postfixList = ["163.com", "gmail.com", "qq.com", "263.com"];
		var txt = document.getElementById("email-input");
		var sug = document.getElementById('email-sug-wrapper');
		var nowSelectTipIndex = 0;

		//对inputDom的输入监听
		txt.oninput = function(e) {
			console.log("event handle");
			//按下的是内容，则重置选中状态，坐标清零，避免光标位置已经计算存入
			//如果按键不是上下及回车重置选中状态nowSelectTipIndex()
			if(!(e.keyCode == 40 || e.keyCode == 38 || e.keyCode == 13)) {
				nowSelectTipIndex == 0;
			}
			//控制email-sug-wrapper的显示/隐藏状态
			judge();
			add();
		};

		//键盘事件响应
		document.addEventListener('keydown', function(e) {
			var e = e || window.event;
			var key = e.which || e.keyCode;
			var list = document.getElementsByTagName('li');
			//向下键
			if(key == 40) {
				for(i = 0; i < list.length; i++) {
					list[i].setAttribute('class', '');
				}
				nowSelectTipIndex++;
				if(nowSelectTipIndex + 1 > list.length) {
					nowSelectTipIndex = 0;
				}
				list[nowSelectTipIndex].setAttribute('class', 'active');
			}
			//向上键
			if(key == 38) {
				for(i = 0; i < list.length; i++) {
					list[i].setAttribute('class', '');
				}
				nowSelectTipIndex--;
				if(nowSelectTipIndex < 0) {
					nowSelectTipIndex = 0;
				}
				list[nowSelectTipIndex].setAttribute('class', 'active');
			}
			//回车键
			if(key == 13) {
				var x = document.getElementsByClassName('active');
				//从当前提示框中选第 nowSelectTipIndex 个Li，将其HTML内容解码后填到input中
				txt.value = htmlDecode(x[0].innerHTML);
				hide();
			}
			//Esc键
			if(key == 27) {
				txt.setSelectionRange(0, -1);//Esc全选文本框内容
				hide();
			}
		});

		//采用事件代理，监听父级点击事件，通过target获取当前li
		sug.addEventListener("click", function(ev) {
			var ev = ev || window.event;
			var target = ev.target || ev.srcElement;
			if(target.nodeName.toLowerCase()=="li"){
			 	hide();
			 	txt.focus();//写在return之前，不然无效
			 	//在把鼠标点击的提示框内容转回输入框时进行解码
			 	return txt.value = htmlDecode(target.innerHTML);
			 	// return txt.value = target.innerHTML;
			}
		});

		// 获取用户输入,并去除首尾空格
		function getText() {
			console.log("event handle");
			// 使用 trim 方法返回 input输入框 的输入内容
			var inputText = txt.value.trim();
			return inputText;
		}

		//判断是否生成新的数组
		function postlist() {
			var userinput = getText();
			var newpostlist = new Array();
			if(userinput.search('@') != 0){
				var len = userinput.search('@');
				//用来拼接的用户输入内容，即只是用@之后的字符串
				var x = userinput.substring(len + 1, userinput.length);
				for(var i = 0; i < postfixList.length; i++) {
					if(postfixList[i].search(x) == 0) {
						newpostlist.push(postfixList[i]);
					}
				}
				//若@后面没有字符串或者新数组newpostlist为空，就返回原来的postfixlist
				if(x === '' || newpostlist == '') {
					return postfixList;
				}
				return newpostlist;
			} else {
				return postfixList;
			}
		}

		//根据输入内容和匹配来生成提示数组
		function promptContent() {
			var t = htmlDecode(getText()); //转码;
			// var t = getText();
			var tips = new Array();
			if(t.indexOf('@') != -1) {
				var p = t.slice(0, t.indexOf('@'));
				for(i = 0; i < postlist().length; i++) {
					tips[i] = p + '@' + postlist()[i];
				}
			} else {
				for( i = 0; i < postfixList.length; i++) {
					tips[i] = t + '@' + postfixList[i];
				}
			}
			return tips;
		}

		//生成提示框中的提示内容
		function add() {
			var sug = document.getElementById("email-sug-wrapper");
			var tips = promptContent();
			while (sug.hasChildNodes()) {
				sug.removeChild(sug.firstChild);
			}
			//将之前的列表清除掉，然后重新生成新的列表
			for(i = 0; i < tips.length; i++) {
				var tip_li = document.createElement('li');
				tip_li.innerHTML = tips[i];
				sug.appendChild(tip_li);
			}
			//初始让第一个选项为选中状态，加类名变粉色（生成li元素之后调用）
			var list = document.getElementsByTagName('li');
			list[0].setAttribute('class', 'active');
		}

		function judge() {
			if(getText() == "") {
				hide();
			} else {
				show();
			}
		}

		function hide() {
			sug.style.display = "none";
		}

		function show() {
			sug.style.display = "block";
		}

		/*1.用浏览器内部转换器实现html转码*/
		function htmlDecode(html) {
			//1.首先动态创建一个容器标签元素，如DIV
			var temp = document.createElement('div');
			//2.然后将要转换的字符串设置为这个元素的innerText(ie支持)或者textContent(火狐，google支持)
			(temp.textContent != undefined ) ? (temp.textContent = html) : (temp.innerText = html);
			//3.最后返回这个元素的innerHTML，即得到经过HTML编码转换的字符串了
			var output = temp.innerHTML;
			temp = null;
			return output;
		}

		/*2.用浏览器内部转换器实现html解码*/
		function htmlDecode(text) {
			//1.首先动态创建一个容器标签元素，如DIV
			var temp = document.createElement("div");
			//2.然后将要转换的字符串设置为这个元素的innerHTML(ie，火狐，google都支持)
			temp.innerHTML = text;
			//3.最后返回这个元素的innerText(ie支持)或者textContent(火狐，google支持)，即得到经过HTML解码的字符串了。
			var output = temp.innerText || temp.textContent;
			temp = null;
			return output;
		}
	</script>
</body>
</html>